// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { CreateProjectData, CreateProjectErrors, CreateProjectResponses, DeleteProjectData, DeleteProjectErrors, DeleteProjectResponses, GetCurrentUserInfoData, GetCurrentUserInfoResponses, GetProjectData, GetProjectErrors, GetProjectResponses, HealthCheckData, HealthCheckResponses, ListProjectsData, ListProjectsErrors, ListProjectsResponses, LoginData, LoginErrors, LoginResponses, LogoutData, LogoutResponses, RefreshData, RefreshErrors, RefreshResponses, RegisterData, RegisterErrors, RegisterResponses, UpdateProjectData, UpdateProjectErrors, UpdateProjectResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

export class Health {
    /**
     * Health Check
     *
     * Health check endpoint.
     *
     * Returns the health status of the application and database connection.
     */
    public static healthCheck<ThrowOnError extends boolean = false>(options?: Options<HealthCheckData, ThrowOnError>) {
        return (options?.client ?? client).get<HealthCheckResponses, unknown, ThrowOnError>({
            responseType: 'json',
            url: '/api/v1/health',
            ...options
        });
    }
}

export class Auth {
    /**
     * Register
     *
     * Register a new user.
     *
     * Args:
     * request: Registration request containing email, name, and password.
     * auth_service: Authentication service.
     *
     * Returns:
     * Access and refresh tokens.
     *
     * Raises:
     * HTTPException: If email is already registered.
     */
    public static register<ThrowOnError extends boolean = false>(options: Options<RegisterData, ThrowOnError>) {
        return (options.client ?? client).post<RegisterResponses, RegisterErrors, ThrowOnError>({
            responseType: 'json',
            url: '/api/v1/auth/register',
            ...options,
            headers: {
                'Content-Type': 'application/json',
                ...options.headers
            }
        });
    }
    
    /**
     * Login
     *
     * Login with email and password.
     *
     * Args:
     * request: Login request containing email and password.
     * auth_service: Authentication service.
     *
     * Returns:
     * Access and refresh tokens.
     *
     * Raises:
     * HTTPException: If credentials are invalid or user is inactive.
     */
    public static login<ThrowOnError extends boolean = false>(options: Options<LoginData, ThrowOnError>) {
        return (options.client ?? client).post<LoginResponses, LoginErrors, ThrowOnError>({
            responseType: 'json',
            url: '/api/v1/auth/login',
            ...options,
            headers: {
                'Content-Type': 'application/json',
                ...options.headers
            }
        });
    }
    
    /**
     * Logout
     *
     * Logout and invalidate the current access token.
     *
     * Args:
     * credentials: HTTP Bearer credentials containing the JWT token.
     * auth_service: Authentication service.
     */
    public static logout<ThrowOnError extends boolean = false>(options?: Options<LogoutData, ThrowOnError>) {
        return (options?.client ?? client).post<LogoutResponses, unknown, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }],
            url: '/api/v1/auth/logout',
            ...options
        });
    }
    
    /**
     * Refresh
     *
     * Refresh access token using a refresh token.
     *
     * Args:
     * request: Refresh token request.
     * auth_service: Authentication service.
     *
     * Returns:
     * New access and refresh tokens.
     *
     * Raises:
     * HTTPException: If refresh token is invalid.
     */
    public static refresh<ThrowOnError extends boolean = false>(options: Options<RefreshData, ThrowOnError>) {
        return (options.client ?? client).post<RefreshResponses, RefreshErrors, ThrowOnError>({
            responseType: 'json',
            url: '/api/v1/auth/refresh',
            ...options,
            headers: {
                'Content-Type': 'application/json',
                ...options.headers
            }
        });
    }
    
    /**
     * Get Current User Info
     *
     * Get current user information.
     *
     * Args:
     * current_user: The authenticated user.
     *
     * Returns:
     * User information.
     */
    public static getCurrentUserInfo<ThrowOnError extends boolean = false>(options?: Options<GetCurrentUserInfoData, ThrowOnError>) {
        return (options?.client ?? client).get<GetCurrentUserInfoResponses, unknown, ThrowOnError>({
            responseType: 'json',
            security: [{ scheme: 'bearer', type: 'http' }],
            url: '/api/v1/auth/me',
            ...options
        });
    }
}

export class Projects {
    /**
     * List Projects
     *
     * List all projects owned by the current user.
     *
     * Args:
     * current_user: The authenticated user.
     * project_service: Project service.
     * skip: Number of records to skip (pagination).
     * limit: Maximum number of records to return.
     *
     * Returns:
     * List of projects owned by the current user.
     */
    public static listProjects<ThrowOnError extends boolean = false>(options?: Options<ListProjectsData, ThrowOnError>) {
        return (options?.client ?? client).get<ListProjectsResponses, ListProjectsErrors, ThrowOnError>({
            responseType: 'json',
            security: [{ scheme: 'bearer', type: 'http' }],
            url: '/api/v1/projects',
            ...options
        });
    }
    
    /**
     * Create Project
     *
     * Create a new project.
     *
     * Args:
     * request: Project creation data.
     * current_user: The authenticated user.
     * project_service: Project service.
     *
     * Returns:
     * The created project.
     *
     * Raises:
     * HTTPException: If slug already exists.
     */
    public static createProject<ThrowOnError extends boolean = false>(options: Options<CreateProjectData, ThrowOnError>) {
        return (options.client ?? client).post<CreateProjectResponses, CreateProjectErrors, ThrowOnError>({
            responseType: 'json',
            security: [{ scheme: 'bearer', type: 'http' }],
            url: '/api/v1/projects',
            ...options,
            headers: {
                'Content-Type': 'application/json',
                ...options.headers
            }
        });
    }
    
    /**
     * Delete Project
     *
     * Delete a project.
     *
     * Args:
     * slug: The project slug.
     * current_user: The authenticated user.
     * project_service: Project service.
     *
     * Raises:
     * HTTPException: If project is not found or user is not the owner.
     */
    public static deleteProject<ThrowOnError extends boolean = false>(options: Options<DeleteProjectData, ThrowOnError>) {
        return (options.client ?? client).delete<DeleteProjectResponses, DeleteProjectErrors, ThrowOnError>({
            security: [{ scheme: 'bearer', type: 'http' }],
            url: '/api/v1/projects/{slug}',
            ...options
        });
    }
    
    /**
     * Get Project
     *
     * Get a project by slug.
     *
     * Args:
     * slug: The project slug.
     * current_user: The authenticated user.
     * project_service: Project service.
     *
     * Returns:
     * The project.
     *
     * Raises:
     * HTTPException: If project is not found or user is not the owner.
     */
    public static getProject<ThrowOnError extends boolean = false>(options: Options<GetProjectData, ThrowOnError>) {
        return (options.client ?? client).get<GetProjectResponses, GetProjectErrors, ThrowOnError>({
            responseType: 'json',
            security: [{ scheme: 'bearer', type: 'http' }],
            url: '/api/v1/projects/{slug}',
            ...options
        });
    }
    
    /**
     * Update Project
     *
     * Update a project.
     *
     * Args:
     * slug: The project slug.
     * request: Project update data.
     * current_user: The authenticated user.
     * project_service: Project service.
     *
     * Returns:
     * The updated project.
     *
     * Raises:
     * HTTPException: If project is not found or user is not the owner.
     */
    public static updateProject<ThrowOnError extends boolean = false>(options: Options<UpdateProjectData, ThrowOnError>) {
        return (options.client ?? client).patch<UpdateProjectResponses, UpdateProjectErrors, ThrowOnError>({
            responseType: 'json',
            security: [{ scheme: 'bearer', type: 'http' }],
            url: '/api/v1/projects/{slug}',
            ...options,
            headers: {
                'Content-Type': 'application/json',
                ...options.headers
            }
        });
    }
}
