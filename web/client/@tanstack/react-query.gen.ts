// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { Auth, Bookmarks, Documents, Health, type Options, ProjectMembers, Projects, Setup, Uploads, Users } from '../sdk.gen';
import type { AddBookmarkData, AddBookmarkError, AddBookmarkResponse, AddMemberData, AddMemberError, AddMemberResponse, CreateAdminData, CreateAdminError, CreateAdminResponse, CreateProjectData, CreateProjectError, CreateProjectResponse, DeleteDocumentData, DeleteDocumentError, DeleteDocumentResponse, DeleteProjectData, DeleteProjectError, DeleteProjectResponse, DeleteUploadData, DeleteUploadError, DeleteUploadResponse, GetBookmarkStatusData, GetBookmarkStatusError, GetBookmarkStatusResponse, GetCurrentUserInfoData, GetCurrentUserInfoResponse, GetDocumentData, GetDocumentError, GetDocumentHistoryData, GetDocumentHistoryError, GetDocumentHistoryResponse, GetDocumentResponse, GetDocumentTreeData, GetDocumentTreeError, GetDocumentTreeResponse, GetProjectActivityData, GetProjectActivityError, GetProjectActivityResponse, GetProjectData, GetProjectError, GetProjectPermissionsData, GetProjectPermissionsError, GetProjectPermissionsResponse, GetProjectResponse, GetSetupStatusData, GetSetupStatusResponse, GetUploadData, GetUploadError, GetUploadResponse, HealthCheckData, HealthCheckResponse, ListBookmarksData, ListBookmarksError, ListBookmarksResponse, ListMembersData, ListMembersError, ListMembersResponse, ListProjectsData, ListProjectsError, ListProjectsResponse, LoginData, LoginError, LoginResponse, LogoutData, LogoutResponse, PutDocumentData, PutDocumentError, PutDocumentResponse, RefreshData, RefreshError, RefreshResponse, RegisterData, RegisterError, RegisterResponse, RemoveBookmarkData, RemoveBookmarkError, RemoveBookmarkResponse, RemoveMemberData, RemoveMemberError, RemoveMemberResponse, ServeFileData, ServeFileError, UpdateMemberRoleData, UpdateMemberRoleError, UpdateMemberRoleResponse, UpdateMyProfileData, UpdateMyProfileError, UpdateMyProfileResponse, UpdateProjectData, UpdateProjectError, UpdateProjectResponse, UploadImageData, UploadImageError, UploadImageResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const healthCheckQueryKey = (options?: Options<HealthCheckData>) => createQueryKey('healthCheck', options);

/**
 * Health Check
 *
 * Health check endpoint.
 *
 * Returns the health status of the application and database connection.
 */
export const healthCheckOptions = (options?: Options<HealthCheckData>) => queryOptions<HealthCheckResponse, DefaultError, HealthCheckResponse, ReturnType<typeof healthCheckQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Health.healthCheck({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: healthCheckQueryKey(options)
});

/**
 * Register
 *
 * Register a new user.
 *
 * Args:
 * request: Registration request containing email, name, and password.
 * auth_service: Authentication service.
 *
 * Returns:
 * Access and refresh tokens.
 *
 * Raises:
 * HTTPException: If email is already registered.
 */
export const registerMutation = (options?: Partial<Options<RegisterData>>): UseMutationOptions<RegisterResponse, RegisterError, Options<RegisterData>> => {
    const mutationOptions: UseMutationOptions<RegisterResponse, RegisterError, Options<RegisterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Auth.register({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Login
 *
 * Login with email and password.
 *
 * Args:
 * request: Login request containing email and password.
 * auth_service: Authentication service.
 *
 * Returns:
 * Access and refresh tokens.
 *
 * Raises:
 * HTTPException: If credentials are invalid or user is inactive.
 */
export const loginMutation = (options?: Partial<Options<LoginData>>): UseMutationOptions<LoginResponse, LoginError, Options<LoginData>> => {
    const mutationOptions: UseMutationOptions<LoginResponse, LoginError, Options<LoginData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Auth.login({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Logout
 *
 * Logout and invalidate the current access token.
 *
 * Args:
 * credentials: HTTP Bearer credentials containing the JWT token.
 * auth_service: Authentication service.
 */
export const logoutMutation = (options?: Partial<Options<LogoutData>>): UseMutationOptions<LogoutResponse, DefaultError, Options<LogoutData>> => {
    const mutationOptions: UseMutationOptions<LogoutResponse, DefaultError, Options<LogoutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Auth.logout({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Refresh
 *
 * Refresh access token using a refresh token.
 *
 * Args:
 * request: Refresh token request.
 * auth_service: Authentication service.
 *
 * Returns:
 * New access and refresh tokens.
 *
 * Raises:
 * HTTPException: If refresh token is invalid.
 */
export const refreshMutation = (options?: Partial<Options<RefreshData>>): UseMutationOptions<RefreshResponse, RefreshError, Options<RefreshData>> => {
    const mutationOptions: UseMutationOptions<RefreshResponse, RefreshError, Options<RefreshData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Auth.refresh({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCurrentUserInfoQueryKey = (options?: Options<GetCurrentUserInfoData>) => createQueryKey('getCurrentUserInfo', options);

/**
 * Get Current User Info
 *
 * Get current user information.
 *
 * Args:
 * current_user: The authenticated user.
 *
 * Returns:
 * User information.
 */
export const getCurrentUserInfoOptions = (options?: Options<GetCurrentUserInfoData>) => queryOptions<GetCurrentUserInfoResponse, DefaultError, GetCurrentUserInfoResponse, ReturnType<typeof getCurrentUserInfoQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Auth.getCurrentUserInfo({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCurrentUserInfoQueryKey(options)
});

/**
 * Update My Profile
 *
 * Update current user's profile.
 *
 * Allows updating:
 * - name: Display name (1-100 characters)
 * - avatar_url: URL to avatar image (max 500 characters)
 * - preferred_locale: Preferred locale code (2-10 characters, e.g., "en", "ja")
 */
export const updateMyProfileMutation = (options?: Partial<Options<UpdateMyProfileData>>): UseMutationOptions<UpdateMyProfileResponse, UpdateMyProfileError, Options<UpdateMyProfileData>> => {
    const mutationOptions: UseMutationOptions<UpdateMyProfileResponse, UpdateMyProfileError, Options<UpdateMyProfileData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Users.updateMyProfile({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listProjectsQueryKey = (options?: Options<ListProjectsData>) => createQueryKey('listProjects', options);

/**
 * List Projects
 *
 * List all projects accessible by the current user.
 *
 * Includes:
 * - Projects owned by the user
 * - Projects where user is a member
 * - Public projects
 *
 * Args:
 * current_user: The authenticated user.
 * project_service: Project service.
 * skip: Number of records to skip (pagination).
 * limit: Maximum number of records to return.
 *
 * Returns:
 * List of accessible projects.
 */
export const listProjectsOptions = (options?: Options<ListProjectsData>) => queryOptions<ListProjectsResponse, ListProjectsError, ListProjectsResponse, ReturnType<typeof listProjectsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Projects.listProjects({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listProjectsQueryKey(options)
});

/**
 * Create Project
 *
 * Create a new project.
 *
 * Args:
 * request: Project creation data.
 * current_user: The authenticated user.
 * project_service: Project service.
 *
 * Returns:
 * The created project.
 *
 * Raises:
 * HTTPException: If slug already exists.
 */
export const createProjectMutation = (options?: Partial<Options<CreateProjectData>>): UseMutationOptions<CreateProjectResponse, CreateProjectError, Options<CreateProjectData>> => {
    const mutationOptions: UseMutationOptions<CreateProjectResponse, CreateProjectError, Options<CreateProjectData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Projects.createProject({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Project
 *
 * Delete a project.
 *
 * Args:
 * slug: The project slug.
 * current_user: The authenticated user.
 * project_service: Project service.
 *
 * Raises:
 * HTTPException: If project is not found or user is not the owner.
 */
export const deleteProjectMutation = (options?: Partial<Options<DeleteProjectData>>): UseMutationOptions<DeleteProjectResponse, DeleteProjectError, Options<DeleteProjectData>> => {
    const mutationOptions: UseMutationOptions<DeleteProjectResponse, DeleteProjectError, Options<DeleteProjectData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Projects.deleteProject({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProjectQueryKey = (options: Options<GetProjectData>) => createQueryKey('getProject', options);

/**
 * Get Project
 *
 * Get a project by slug.
 *
 * Args:
 * slug: The project slug.
 * current_user: The authenticated user.
 * project_service: Project service.
 * member_repo: Project member repository.
 *
 * Returns:
 * The project.
 *
 * Raises:
 * HTTPException: If project is not found or user does not have access.
 */
export const getProjectOptions = (options: Options<GetProjectData>) => queryOptions<GetProjectResponse, GetProjectError, GetProjectResponse, ReturnType<typeof getProjectQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Projects.getProject({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getProjectQueryKey(options)
});

/**
 * Update Project
 *
 * Update a project.
 *
 * Args:
 * slug: The project slug.
 * request: Project update data.
 * current_user: The authenticated user.
 * project_service: Project service.
 *
 * Returns:
 * The updated project.
 *
 * Raises:
 * HTTPException: If project is not found or user is not the owner.
 */
export const updateProjectMutation = (options?: Partial<Options<UpdateProjectData>>): UseMutationOptions<UpdateProjectResponse, UpdateProjectError, Options<UpdateProjectData>> => {
    const mutationOptions: UseMutationOptions<UpdateProjectResponse, UpdateProjectError, Options<UpdateProjectData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Projects.updateProject({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProjectPermissionsQueryKey = (options: Options<GetProjectPermissionsData>) => createQueryKey('getProjectPermissions', options);

/**
 * Get Project Permissions
 *
 * Get the current user's permissions on a project.
 *
 * Returns the list of permissions the authenticated user has on the project,
 * along with their role (owner, admin, editor, viewer, or null for non-members).
 *
 * For public projects, non-members will have view permission with null role.
 *
 * Args:
 * slug: The project slug.
 * current_user: The authenticated user.
 * project_service: Project service.
 * member_repo: Project member repository.
 *
 * Returns:
 * User's permissions and role on the project.
 *
 * Raises:
 * HTTPException: If project is not found.
 */
export const getProjectPermissionsOptions = (options: Options<GetProjectPermissionsData>) => queryOptions<GetProjectPermissionsResponse, GetProjectPermissionsError, GetProjectPermissionsResponse, ReturnType<typeof getProjectPermissionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Projects.getProjectPermissions({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getProjectPermissionsQueryKey(options)
});

export const getDocumentTreeQueryKey = (options: Options<GetDocumentTreeData>) => createQueryKey('getDocumentTree', options);

/**
 * Get Document Tree
 *
 * Get document tree for a project.
 *
 * Args:
 * slug: The project slug.
 * current_user: The authenticated user.
 * document_service: Document service.
 *
 * Returns:
 * List of root-level document tree nodes.
 */
export const getDocumentTreeOptions = (options: Options<GetDocumentTreeData>) => queryOptions<GetDocumentTreeResponse, GetDocumentTreeError, GetDocumentTreeResponse, ReturnType<typeof getDocumentTreeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Documents.getDocumentTree({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDocumentTreeQueryKey(options)
});

export const getDocumentHistoryQueryKey = (options: Options<GetDocumentHistoryData>) => createQueryKey('getDocumentHistory', options);

/**
 * Get Document History
 *
 * Get document revision history.
 *
 * Args:
 * slug: The project slug.
 * path: Document path.
 * current_user: The authenticated user.
 * document_service: Document service.
 * skip: Number of records to skip (pagination).
 * limit: Maximum number of records to return.
 *
 * Returns:
 * List of document revisions.
 */
export const getDocumentHistoryOptions = (options: Options<GetDocumentHistoryData>) => queryOptions<GetDocumentHistoryResponse, GetDocumentHistoryError, GetDocumentHistoryResponse, ReturnType<typeof getDocumentHistoryQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Documents.getDocumentHistory({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDocumentHistoryQueryKey(options)
});

/**
 * Delete Document
 *
 * Delete document.
 *
 * Args:
 * slug: The project slug.
 * path: Document path.
 * current_user: The authenticated user.
 * document_service: Document service.
 * message: Optional delete message.
 */
export const deleteDocumentMutation = (options?: Partial<Options<DeleteDocumentData>>): UseMutationOptions<DeleteDocumentResponse, DeleteDocumentError, Options<DeleteDocumentData>> => {
    const mutationOptions: UseMutationOptions<DeleteDocumentResponse, DeleteDocumentError, Options<DeleteDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Documents.deleteDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDocumentQueryKey = (options: Options<GetDocumentData>) => createQueryKey('getDocument', options);

/**
 * Get Document
 *
 * Get document by path.
 *
 * Args:
 * slug: The project slug.
 * path: Document path.
 * current_user: The authenticated user.
 * document_service: Document service.
 *
 * Returns:
 * The document.
 */
export const getDocumentOptions = (options: Options<GetDocumentData>) => queryOptions<GetDocumentResponse, GetDocumentError, GetDocumentResponse, ReturnType<typeof getDocumentQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Documents.getDocument({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDocumentQueryKey(options)
});

/**
 * Put Document
 *
 * Create or update document.
 *
 * Args:
 * slug: The project slug.
 * path: Document path.
 * request: Document data.
 * current_user: The authenticated user.
 * document_service: Document service.
 *
 * Returns:
 * The created or updated document.
 */
export const putDocumentMutation = (options?: Partial<Options<PutDocumentData>>): UseMutationOptions<PutDocumentResponse, PutDocumentError, Options<PutDocumentData>> => {
    const mutationOptions: UseMutationOptions<PutDocumentResponse, PutDocumentError, Options<PutDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Documents.putDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProjectActivityQueryKey = (options: Options<GetProjectActivityData>) => createQueryKey('getProjectActivity', options);

/**
 * Get Project Activity
 *
 * Get project activity feed.
 *
 * Args:
 * slug: The project slug.
 * current_user: The authenticated user.
 * document_service: Document service.
 * skip: Number of records to skip (pagination).
 * limit: Maximum number of records to return.
 *
 * Returns:
 * List of revision batches with document summaries.
 */
export const getProjectActivityOptions = (options: Options<GetProjectActivityData>) => queryOptions<GetProjectActivityResponse, GetProjectActivityError, GetProjectActivityResponse, ReturnType<typeof getProjectActivityQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Documents.getProjectActivity({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getProjectActivityQueryKey(options)
});

export const listMembersQueryKey = (options: Options<ListMembersData>) => createQueryKey('listMembers', options);

/**
 * List Members
 *
 * List all members of a project.
 *
 * All project members (viewer+) can view the member list.
 *
 * Args:
 * slug: The project slug.
 * current_user: The authenticated user.
 * member_service: Project member service.
 * skip: Number of records to skip (pagination).
 * limit: Maximum number of records to return.
 *
 * Returns:
 * List of project members with user details.
 */
export const listMembersOptions = (options: Options<ListMembersData>) => queryOptions<ListMembersResponse, ListMembersError, ListMembersResponse, ReturnType<typeof listMembersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await ProjectMembers.listMembers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listMembersQueryKey(options)
});

/**
 * Add Member
 *
 * Add a member to a project.
 *
 * Only project admins and owners can add members.
 *
 * Args:
 * slug: The project slug.
 * request: Member creation data.
 * current_user: The authenticated user.
 * member_service: Project member service.
 *
 * Returns:
 * The created project member.
 */
export const addMemberMutation = (options?: Partial<Options<AddMemberData>>): UseMutationOptions<AddMemberResponse, AddMemberError, Options<AddMemberData>> => {
    const mutationOptions: UseMutationOptions<AddMemberResponse, AddMemberError, Options<AddMemberData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ProjectMembers.addMember({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove Member
 *
 * Remove a member from a project.
 *
 * Only project admins and owners can remove members.
 * Members can also remove themselves (leave the project).
 *
 * Args:
 * slug: The project slug.
 * member_id: UUID of the member record.
 * current_user: The authenticated user.
 * member_service: Project member service.
 */
export const removeMemberMutation = (options?: Partial<Options<RemoveMemberData>>): UseMutationOptions<RemoveMemberResponse, RemoveMemberError, Options<RemoveMemberData>> => {
    const mutationOptions: UseMutationOptions<RemoveMemberResponse, RemoveMemberError, Options<RemoveMemberData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ProjectMembers.removeMember({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Member Role
 *
 * Update a member's role.
 *
 * Only project admins and owners can update roles.
 * Admins cannot modify their own role.
 *
 * Args:
 * slug: The project slug.
 * member_id: UUID of the member record.
 * request: Member update data.
 * current_user: The authenticated user.
 * member_service: Project member service.
 *
 * Returns:
 * The updated project member.
 */
export const updateMemberRoleMutation = (options?: Partial<Options<UpdateMemberRoleData>>): UseMutationOptions<UpdateMemberRoleResponse, UpdateMemberRoleError, Options<UpdateMemberRoleData>> => {
    const mutationOptions: UseMutationOptions<UpdateMemberRoleResponse, UpdateMemberRoleError, Options<UpdateMemberRoleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ProjectMembers.updateMemberRole({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listBookmarksQueryKey = (options?: Options<ListBookmarksData>) => createQueryKey('listBookmarks', options);

/**
 * List Bookmarks
 *
 * List all bookmarked projects for the current user.
 *
 * Args:
 * current_user: The authenticated user.
 * bookmark_service: Bookmark service.
 * skip: Number of records to skip (pagination).
 * limit: Maximum number of records to return.
 *
 * Returns:
 * List of bookmarked projects with details.
 */
export const listBookmarksOptions = (options?: Options<ListBookmarksData>) => queryOptions<ListBookmarksResponse, ListBookmarksError, ListBookmarksResponse, ReturnType<typeof listBookmarksQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Bookmarks.listBookmarks({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listBookmarksQueryKey(options)
});

/**
 * Remove Bookmark
 *
 * Remove a bookmark for a project.
 *
 * This operation is idempotent - calling it when no bookmark
 * exists returns 204 without error.
 *
 * Args:
 * slug: The project slug.
 * current_user: The authenticated user.
 * bookmark_service: Bookmark service.
 *
 * Raises:
 * HTTPException: If project is not found.
 */
export const removeBookmarkMutation = (options?: Partial<Options<RemoveBookmarkData>>): UseMutationOptions<RemoveBookmarkResponse, RemoveBookmarkError, Options<RemoveBookmarkData>> => {
    const mutationOptions: UseMutationOptions<RemoveBookmarkResponse, RemoveBookmarkError, Options<RemoveBookmarkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Bookmarks.removeBookmark({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBookmarkStatusQueryKey = (options: Options<GetBookmarkStatusData>) => createQueryKey('getBookmarkStatus', options);

/**
 * Get Bookmark Status
 *
 * Check if a project is bookmarked by the current user.
 *
 * Args:
 * slug: The project slug.
 * current_user: The authenticated user.
 * bookmark_service: Bookmark service.
 *
 * Returns:
 * Bookmark status.
 *
 * Raises:
 * HTTPException: If project is not found.
 */
export const getBookmarkStatusOptions = (options: Options<GetBookmarkStatusData>) => queryOptions<GetBookmarkStatusResponse, GetBookmarkStatusError, GetBookmarkStatusResponse, ReturnType<typeof getBookmarkStatusQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Bookmarks.getBookmarkStatus({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBookmarkStatusQueryKey(options)
});

/**
 * Add Bookmark
 *
 * Add a bookmark for a project.
 *
 * This operation is idempotent - calling it multiple times
 * returns the same bookmark without error.
 *
 * Args:
 * slug: The project slug.
 * current_user: The authenticated user.
 * bookmark_service: Bookmark service.
 *
 * Returns:
 * The bookmark.
 *
 * Raises:
 * HTTPException: If project is not found or user does not have access.
 */
export const addBookmarkMutation = (options?: Partial<Options<AddBookmarkData>>): UseMutationOptions<AddBookmarkResponse, AddBookmarkError, Options<AddBookmarkData>> => {
    const mutationOptions: UseMutationOptions<AddBookmarkResponse, AddBookmarkError, Options<AddBookmarkData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Bookmarks.addBookmark({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSetupStatusQueryKey = (options?: Options<GetSetupStatusData>) => createQueryKey('getSetupStatus', options);

/**
 * Get Setup Status
 *
 * Get the setup status.
 *
 * Returns:
 * Setup status indicating if setup is completed and if admin is required.
 */
export const getSetupStatusOptions = (options?: Options<GetSetupStatusData>) => queryOptions<GetSetupStatusResponse, DefaultError, GetSetupStatusResponse, ReturnType<typeof getSetupStatusQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Setup.getSetupStatus({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSetupStatusQueryKey(options)
});

/**
 * Create Admin
 *
 * Create a new admin user.
 *
 * Args:
 * request: The request containing the admin user's email, name, and password.
 *
 * Returns:
 * Access and refresh tokens.
 *
 * Raises:
 * HTTPException: If setup is already completed (403) or email exists (400).
 */
export const createAdminMutation = (options?: Partial<Options<CreateAdminData>>): UseMutationOptions<CreateAdminResponse, CreateAdminError, Options<CreateAdminData>> => {
    const mutationOptions: UseMutationOptions<CreateAdminResponse, CreateAdminError, Options<CreateAdminData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Setup.createAdmin({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Upload Image
 *
 * Upload an image to a project.
 *
 * Supported formats: PNG, JPEG, GIF, WebP
 * Maximum file size: 10MB (configurable)
 * Images are automatically resized (max 2048px) and compressed.
 *
 * Args:
 * project_id: UUID of the project.
 * file: Image file to upload.
 * current_user: The authenticated user.
 * upload_service: Upload service.
 * project_repo: Project repository.
 * member_repo: Project member repository.
 *
 * Returns:
 * Upload metadata including URL.
 *
 * Raises:
 * HTTPException: Various HTTP errors for validation failures.
 */
export const uploadImageMutation = (options?: Partial<Options<UploadImageData>>): UseMutationOptions<UploadImageResponse, UploadImageError, Options<UploadImageData>> => {
    const mutationOptions: UseMutationOptions<UploadImageResponse, UploadImageError, Options<UploadImageData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Uploads.uploadImage({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Upload
 *
 * Delete an upload.
 *
 * Only the uploader can delete their uploads.
 *
 * Args:
 * upload_id: UUID of the upload to delete.
 * current_user: The authenticated user.
 * upload_service: Upload service.
 *
 * Raises:
 * HTTPException: If upload not found or permission denied.
 */
export const deleteUploadMutation = (options?: Partial<Options<DeleteUploadData>>): UseMutationOptions<DeleteUploadResponse, DeleteUploadError, Options<DeleteUploadData>> => {
    const mutationOptions: UseMutationOptions<DeleteUploadResponse, DeleteUploadError, Options<DeleteUploadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Uploads.deleteUpload({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUploadQueryKey = (options: Options<GetUploadData>) => createQueryKey('getUpload', options);

/**
 * Get Upload
 *
 * Get upload metadata by ID.
 *
 * Args:
 * upload_id: UUID of the upload.
 * current_user: The authenticated user.
 * upload_service: Upload service.
 * project_repo: Project repository.
 * member_repo: Project member repository.
 *
 * Returns:
 * Upload metadata.
 *
 * Raises:
 * HTTPException: If upload not found or access denied.
 */
export const getUploadOptions = (options: Options<GetUploadData>) => queryOptions<GetUploadResponse, GetUploadError, GetUploadResponse, ReturnType<typeof getUploadQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Uploads.getUpload({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUploadQueryKey(options)
});

export const serveFileQueryKey = (options: Options<ServeFileData>) => createQueryKey('serveFile', options);

/**
 * Serve File
 *
 * Serve uploaded file content.
 *
 * Note: In production, this should be handled by a CDN or reverse proxy
 * for better performance.
 *
 * Args:
 * storage_path: Storage path of the file.
 * upload_service: Upload service.
 *
 * Returns:
 * File content as HTTP response.
 *
 * Raises:
 * HTTPException: If file not found.
 */
export const serveFileOptions = (options: Options<ServeFileData>) => queryOptions<unknown, ServeFileError, unknown, ReturnType<typeof serveFileQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Uploads.serveFile({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: serveFileQueryKey(options)
});
