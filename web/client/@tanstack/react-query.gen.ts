// This file is auto-generated by @hey-api/openapi-ts

import {
  type DefaultError,
  queryOptions,
  type UseMutationOptions,
} from '@tanstack/react-query';
import type { AxiosError } from 'axios';

import { client } from '../client.gen';
import {
  getCurrentUserInfoApiV1AuthMeGet,
  healthCheckApiV1HealthGet,
  loginApiV1AuthLoginPost,
  logoutApiV1AuthLogoutPost,
  type Options,
  refreshApiV1AuthRefreshPost,
  registerApiV1AuthRegisterPost,
} from '../sdk.gen';
import type {
  GetCurrentUserInfoApiV1AuthMeGetData,
  GetCurrentUserInfoApiV1AuthMeGetResponse,
  HealthCheckApiV1HealthGetData,
  HealthCheckApiV1HealthGetResponse,
  LoginApiV1AuthLoginPostData,
  LoginApiV1AuthLoginPostError,
  LoginApiV1AuthLoginPostResponse,
  LogoutApiV1AuthLogoutPostData,
  LogoutApiV1AuthLogoutPostResponse,
  RefreshApiV1AuthRefreshPostData,
  RefreshApiV1AuthRefreshPostError,
  RefreshApiV1AuthRefreshPostResponse,
  RegisterApiV1AuthRegisterPostData,
  RegisterApiV1AuthRegisterPostError,
  RegisterApiV1AuthRegisterPostResponse,
} from '../types.gen';

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string;
    _infinite?: boolean;
    tags?: ReadonlyArray<string>;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
  tags?: ReadonlyArray<string>
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseURL:
      options?.baseURL || (options?.client ?? client).getConfig().baseURL,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (tags) {
    params.tags = tags;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const healthCheckApiV1HealthGetQueryKey = (
  options?: Options<HealthCheckApiV1HealthGetData>
) => createQueryKey('healthCheckApiV1HealthGet', options);

/**
 * Health Check
 *
 * Health check endpoint.
 *
 * Returns the health status of the application and database connection.
 */
export const healthCheckApiV1HealthGetOptions = (
  options?: Options<HealthCheckApiV1HealthGetData>
) =>
  queryOptions<
    HealthCheckApiV1HealthGetResponse,
    AxiosError<DefaultError>,
    HealthCheckApiV1HealthGetResponse,
    ReturnType<typeof healthCheckApiV1HealthGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await healthCheckApiV1HealthGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: healthCheckApiV1HealthGetQueryKey(options),
  });

/**
 * Register
 *
 * Register a new user.
 *
 * Args:
 * request: Registration request containing email, name, and password.
 * db: Database session.
 *
 * Returns:
 * Access and refresh tokens.
 *
 * Raises:
 * HTTPException: If email is already registered.
 */
export const registerApiV1AuthRegisterPostMutation = (
  options?: Partial<Options<RegisterApiV1AuthRegisterPostData>>
): UseMutationOptions<
  RegisterApiV1AuthRegisterPostResponse,
  AxiosError<RegisterApiV1AuthRegisterPostError>,
  Options<RegisterApiV1AuthRegisterPostData>
> => {
  const mutationOptions: UseMutationOptions<
    RegisterApiV1AuthRegisterPostResponse,
    AxiosError<RegisterApiV1AuthRegisterPostError>,
    Options<RegisterApiV1AuthRegisterPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await registerApiV1AuthRegisterPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Login
 *
 * Login with email and password.
 *
 * Args:
 * request: Login request containing email and password.
 * db: Database session.
 *
 * Returns:
 * Access and refresh tokens.
 *
 * Raises:
 * HTTPException: If credentials are invalid.
 */
export const loginApiV1AuthLoginPostMutation = (
  options?: Partial<Options<LoginApiV1AuthLoginPostData>>
): UseMutationOptions<
  LoginApiV1AuthLoginPostResponse,
  AxiosError<LoginApiV1AuthLoginPostError>,
  Options<LoginApiV1AuthLoginPostData>
> => {
  const mutationOptions: UseMutationOptions<
    LoginApiV1AuthLoginPostResponse,
    AxiosError<LoginApiV1AuthLoginPostError>,
    Options<LoginApiV1AuthLoginPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await loginApiV1AuthLoginPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Logout
 *
 * Logout and invalidate the current access token.
 *
 * Args:
 * credentials: HTTP Bearer credentials containing the JWT token.
 */
export const logoutApiV1AuthLogoutPostMutation = (
  options?: Partial<Options<LogoutApiV1AuthLogoutPostData>>
): UseMutationOptions<
  LogoutApiV1AuthLogoutPostResponse,
  AxiosError<DefaultError>,
  Options<LogoutApiV1AuthLogoutPostData>
> => {
  const mutationOptions: UseMutationOptions<
    LogoutApiV1AuthLogoutPostResponse,
    AxiosError<DefaultError>,
    Options<LogoutApiV1AuthLogoutPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await logoutApiV1AuthLogoutPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Refresh
 *
 * Refresh access token using a refresh token.
 *
 * Args:
 * request: Refresh token request.
 * db: Database session.
 *
 * Returns:
 * New access and refresh tokens.
 *
 * Raises:
 * HTTPException: If refresh token is invalid.
 */
export const refreshApiV1AuthRefreshPostMutation = (
  options?: Partial<Options<RefreshApiV1AuthRefreshPostData>>
): UseMutationOptions<
  RefreshApiV1AuthRefreshPostResponse,
  AxiosError<RefreshApiV1AuthRefreshPostError>,
  Options<RefreshApiV1AuthRefreshPostData>
> => {
  const mutationOptions: UseMutationOptions<
    RefreshApiV1AuthRefreshPostResponse,
    AxiosError<RefreshApiV1AuthRefreshPostError>,
    Options<RefreshApiV1AuthRefreshPostData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await refreshApiV1AuthRefreshPost({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCurrentUserInfoApiV1AuthMeGetQueryKey = (
  options?: Options<GetCurrentUserInfoApiV1AuthMeGetData>
) => createQueryKey('getCurrentUserInfoApiV1AuthMeGet', options);

/**
 * Get Current User Info
 *
 * Get current user information.
 *
 * Args:
 * current_user: The authenticated user.
 *
 * Returns:
 * User information.
 */
export const getCurrentUserInfoApiV1AuthMeGetOptions = (
  options?: Options<GetCurrentUserInfoApiV1AuthMeGetData>
) =>
  queryOptions<
    GetCurrentUserInfoApiV1AuthMeGetResponse,
    AxiosError<DefaultError>,
    GetCurrentUserInfoApiV1AuthMeGetResponse,
    ReturnType<typeof getCurrentUserInfoApiV1AuthMeGetQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCurrentUserInfoApiV1AuthMeGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCurrentUserInfoApiV1AuthMeGetQueryKey(options),
  });
