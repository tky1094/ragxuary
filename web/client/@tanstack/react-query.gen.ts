// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { Auth, Documents, Health, type Options, ProjectMembers, Projects, Users } from '../sdk.gen';
import type { AddMemberData, AddMemberError, AddMemberResponse, CreateProjectData, CreateProjectError, CreateProjectResponse, DeleteDocumentData, DeleteDocumentError, DeleteDocumentResponse, DeleteProjectData, DeleteProjectError, DeleteProjectResponse, GetCurrentUserInfoData, GetCurrentUserInfoResponse, GetDocumentData, GetDocumentError, GetDocumentHistoryData, GetDocumentHistoryError, GetDocumentHistoryResponse, GetDocumentResponse, GetDocumentTreeData, GetDocumentTreeError, GetDocumentTreeResponse, GetProjectActivityData, GetProjectActivityError, GetProjectActivityResponse, GetProjectData, GetProjectError, GetProjectResponse, HealthCheckData, HealthCheckResponse, ListMembersData, ListMembersError, ListMembersResponse, ListProjectsData, ListProjectsError, ListProjectsResponse, LoginData, LoginError, LoginResponse, LogoutData, LogoutResponse, PutDocumentData, PutDocumentError, PutDocumentResponse, RefreshData, RefreshError, RefreshResponse, RegisterData, RegisterError, RegisterResponse, RemoveMemberData, RemoveMemberError, RemoveMemberResponse, UpdateMemberRoleData, UpdateMemberRoleError, UpdateMemberRoleResponse, UpdateMyProfileData, UpdateMyProfileError, UpdateMyProfileResponse, UpdateProjectData, UpdateProjectError, UpdateProjectResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const healthCheckQueryKey = (options?: Options<HealthCheckData>) => createQueryKey('healthCheck', options);

/**
 * Health Check
 *
 * Health check endpoint.
 *
 * Returns the health status of the application and database connection.
 */
export const healthCheckOptions = (options?: Options<HealthCheckData>) => queryOptions<HealthCheckResponse, DefaultError, HealthCheckResponse, ReturnType<typeof healthCheckQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Health.healthCheck({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: healthCheckQueryKey(options)
});

/**
 * Register
 *
 * Register a new user.
 *
 * Args:
 * request: Registration request containing email, name, and password.
 * auth_service: Authentication service.
 *
 * Returns:
 * Access and refresh tokens.
 *
 * Raises:
 * HTTPException: If email is already registered.
 */
export const registerMutation = (options?: Partial<Options<RegisterData>>): UseMutationOptions<RegisterResponse, RegisterError, Options<RegisterData>> => {
    const mutationOptions: UseMutationOptions<RegisterResponse, RegisterError, Options<RegisterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Auth.register({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Login
 *
 * Login with email and password.
 *
 * Args:
 * request: Login request containing email and password.
 * auth_service: Authentication service.
 *
 * Returns:
 * Access and refresh tokens.
 *
 * Raises:
 * HTTPException: If credentials are invalid or user is inactive.
 */
export const loginMutation = (options?: Partial<Options<LoginData>>): UseMutationOptions<LoginResponse, LoginError, Options<LoginData>> => {
    const mutationOptions: UseMutationOptions<LoginResponse, LoginError, Options<LoginData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Auth.login({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Logout
 *
 * Logout and invalidate the current access token.
 *
 * Args:
 * credentials: HTTP Bearer credentials containing the JWT token.
 * auth_service: Authentication service.
 */
export const logoutMutation = (options?: Partial<Options<LogoutData>>): UseMutationOptions<LogoutResponse, DefaultError, Options<LogoutData>> => {
    const mutationOptions: UseMutationOptions<LogoutResponse, DefaultError, Options<LogoutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Auth.logout({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Refresh
 *
 * Refresh access token using a refresh token.
 *
 * Args:
 * request: Refresh token request.
 * auth_service: Authentication service.
 *
 * Returns:
 * New access and refresh tokens.
 *
 * Raises:
 * HTTPException: If refresh token is invalid.
 */
export const refreshMutation = (options?: Partial<Options<RefreshData>>): UseMutationOptions<RefreshResponse, RefreshError, Options<RefreshData>> => {
    const mutationOptions: UseMutationOptions<RefreshResponse, RefreshError, Options<RefreshData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Auth.refresh({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCurrentUserInfoQueryKey = (options?: Options<GetCurrentUserInfoData>) => createQueryKey('getCurrentUserInfo', options);

/**
 * Get Current User Info
 *
 * Get current user information.
 *
 * Args:
 * current_user: The authenticated user.
 *
 * Returns:
 * User information.
 */
export const getCurrentUserInfoOptions = (options?: Options<GetCurrentUserInfoData>) => queryOptions<GetCurrentUserInfoResponse, DefaultError, GetCurrentUserInfoResponse, ReturnType<typeof getCurrentUserInfoQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Auth.getCurrentUserInfo({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCurrentUserInfoQueryKey(options)
});

/**
 * Update My Profile
 *
 * Update current user's profile.
 *
 * Allows updating:
 * - name: Display name (1-100 characters)
 * - avatar_url: URL to avatar image (max 500 characters)
 * - preferred_locale: Preferred locale code (2-10 characters, e.g., "en", "ja")
 */
export const updateMyProfileMutation = (options?: Partial<Options<UpdateMyProfileData>>): UseMutationOptions<UpdateMyProfileResponse, UpdateMyProfileError, Options<UpdateMyProfileData>> => {
    const mutationOptions: UseMutationOptions<UpdateMyProfileResponse, UpdateMyProfileError, Options<UpdateMyProfileData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Users.updateMyProfile({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listProjectsQueryKey = (options?: Options<ListProjectsData>) => createQueryKey('listProjects', options);

/**
 * List Projects
 *
 * List all projects accessible by the current user.
 *
 * Includes:
 * - Projects owned by the user
 * - Projects where user is a member
 * - Public projects
 *
 * Args:
 * current_user: The authenticated user.
 * project_service: Project service.
 * skip: Number of records to skip (pagination).
 * limit: Maximum number of records to return.
 *
 * Returns:
 * List of accessible projects.
 */
export const listProjectsOptions = (options?: Options<ListProjectsData>) => queryOptions<ListProjectsResponse, ListProjectsError, ListProjectsResponse, ReturnType<typeof listProjectsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Projects.listProjects({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listProjectsQueryKey(options)
});

/**
 * Create Project
 *
 * Create a new project.
 *
 * Args:
 * request: Project creation data.
 * current_user: The authenticated user.
 * project_service: Project service.
 *
 * Returns:
 * The created project.
 *
 * Raises:
 * HTTPException: If slug already exists.
 */
export const createProjectMutation = (options?: Partial<Options<CreateProjectData>>): UseMutationOptions<CreateProjectResponse, CreateProjectError, Options<CreateProjectData>> => {
    const mutationOptions: UseMutationOptions<CreateProjectResponse, CreateProjectError, Options<CreateProjectData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Projects.createProject({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Project
 *
 * Delete a project.
 *
 * Args:
 * slug: The project slug.
 * current_user: The authenticated user.
 * project_service: Project service.
 *
 * Raises:
 * HTTPException: If project is not found or user is not the owner.
 */
export const deleteProjectMutation = (options?: Partial<Options<DeleteProjectData>>): UseMutationOptions<DeleteProjectResponse, DeleteProjectError, Options<DeleteProjectData>> => {
    const mutationOptions: UseMutationOptions<DeleteProjectResponse, DeleteProjectError, Options<DeleteProjectData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Projects.deleteProject({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProjectQueryKey = (options: Options<GetProjectData>) => createQueryKey('getProject', options);

/**
 * Get Project
 *
 * Get a project by slug.
 *
 * Args:
 * slug: The project slug.
 * current_user: The authenticated user.
 * project_service: Project service.
 * member_repo: Project member repository.
 *
 * Returns:
 * The project.
 *
 * Raises:
 * HTTPException: If project is not found or user does not have access.
 */
export const getProjectOptions = (options: Options<GetProjectData>) => queryOptions<GetProjectResponse, GetProjectError, GetProjectResponse, ReturnType<typeof getProjectQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Projects.getProject({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getProjectQueryKey(options)
});

/**
 * Update Project
 *
 * Update a project.
 *
 * Args:
 * slug: The project slug.
 * request: Project update data.
 * current_user: The authenticated user.
 * project_service: Project service.
 *
 * Returns:
 * The updated project.
 *
 * Raises:
 * HTTPException: If project is not found or user is not the owner.
 */
export const updateProjectMutation = (options?: Partial<Options<UpdateProjectData>>): UseMutationOptions<UpdateProjectResponse, UpdateProjectError, Options<UpdateProjectData>> => {
    const mutationOptions: UseMutationOptions<UpdateProjectResponse, UpdateProjectError, Options<UpdateProjectData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Projects.updateProject({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDocumentTreeQueryKey = (options: Options<GetDocumentTreeData>) => createQueryKey('getDocumentTree', options);

/**
 * Get Document Tree
 *
 * Get document tree for a project.
 *
 * Args:
 * slug: The project slug.
 * current_user: The authenticated user.
 * document_service: Document service.
 *
 * Returns:
 * List of root-level document tree nodes.
 */
export const getDocumentTreeOptions = (options: Options<GetDocumentTreeData>) => queryOptions<GetDocumentTreeResponse, GetDocumentTreeError, GetDocumentTreeResponse, ReturnType<typeof getDocumentTreeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Documents.getDocumentTree({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDocumentTreeQueryKey(options)
});

export const getDocumentHistoryQueryKey = (options: Options<GetDocumentHistoryData>) => createQueryKey('getDocumentHistory', options);

/**
 * Get Document History
 *
 * Get document revision history.
 *
 * Args:
 * slug: The project slug.
 * path: Document path.
 * current_user: The authenticated user.
 * document_service: Document service.
 * skip: Number of records to skip (pagination).
 * limit: Maximum number of records to return.
 *
 * Returns:
 * List of document revisions.
 */
export const getDocumentHistoryOptions = (options: Options<GetDocumentHistoryData>) => queryOptions<GetDocumentHistoryResponse, GetDocumentHistoryError, GetDocumentHistoryResponse, ReturnType<typeof getDocumentHistoryQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Documents.getDocumentHistory({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDocumentHistoryQueryKey(options)
});

/**
 * Delete Document
 *
 * Delete document.
 *
 * Args:
 * slug: The project slug.
 * path: Document path.
 * current_user: The authenticated user.
 * document_service: Document service.
 * message: Optional delete message.
 */
export const deleteDocumentMutation = (options?: Partial<Options<DeleteDocumentData>>): UseMutationOptions<DeleteDocumentResponse, DeleteDocumentError, Options<DeleteDocumentData>> => {
    const mutationOptions: UseMutationOptions<DeleteDocumentResponse, DeleteDocumentError, Options<DeleteDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Documents.deleteDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDocumentQueryKey = (options: Options<GetDocumentData>) => createQueryKey('getDocument', options);

/**
 * Get Document
 *
 * Get document by path.
 *
 * Args:
 * slug: The project slug.
 * path: Document path.
 * current_user: The authenticated user.
 * document_service: Document service.
 *
 * Returns:
 * The document.
 */
export const getDocumentOptions = (options: Options<GetDocumentData>) => queryOptions<GetDocumentResponse, GetDocumentError, GetDocumentResponse, ReturnType<typeof getDocumentQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Documents.getDocument({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDocumentQueryKey(options)
});

/**
 * Put Document
 *
 * Create or update document.
 *
 * Args:
 * slug: The project slug.
 * path: Document path.
 * request: Document data.
 * current_user: The authenticated user.
 * document_service: Document service.
 *
 * Returns:
 * The created or updated document.
 */
export const putDocumentMutation = (options?: Partial<Options<PutDocumentData>>): UseMutationOptions<PutDocumentResponse, PutDocumentError, Options<PutDocumentData>> => {
    const mutationOptions: UseMutationOptions<PutDocumentResponse, PutDocumentError, Options<PutDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Documents.putDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProjectActivityQueryKey = (options: Options<GetProjectActivityData>) => createQueryKey('getProjectActivity', options);

/**
 * Get Project Activity
 *
 * Get project activity feed.
 *
 * Args:
 * slug: The project slug.
 * current_user: The authenticated user.
 * document_service: Document service.
 * skip: Number of records to skip (pagination).
 * limit: Maximum number of records to return.
 *
 * Returns:
 * List of revision batches with document summaries.
 */
export const getProjectActivityOptions = (options: Options<GetProjectActivityData>) => queryOptions<GetProjectActivityResponse, GetProjectActivityError, GetProjectActivityResponse, ReturnType<typeof getProjectActivityQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Documents.getProjectActivity({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getProjectActivityQueryKey(options)
});

export const listMembersQueryKey = (options: Options<ListMembersData>) => createQueryKey('listMembers', options);

/**
 * List Members
 *
 * List all members of a project.
 *
 * All project members (viewer+) can view the member list.
 *
 * Args:
 * slug: The project slug.
 * current_user: The authenticated user.
 * member_service: Project member service.
 * skip: Number of records to skip (pagination).
 * limit: Maximum number of records to return.
 *
 * Returns:
 * List of project members with user details.
 */
export const listMembersOptions = (options: Options<ListMembersData>) => queryOptions<ListMembersResponse, ListMembersError, ListMembersResponse, ReturnType<typeof listMembersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await ProjectMembers.listMembers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listMembersQueryKey(options)
});

/**
 * Add Member
 *
 * Add a member to a project.
 *
 * Only project admins and owners can add members.
 *
 * Args:
 * slug: The project slug.
 * request: Member creation data.
 * current_user: The authenticated user.
 * member_service: Project member service.
 *
 * Returns:
 * The created project member.
 */
export const addMemberMutation = (options?: Partial<Options<AddMemberData>>): UseMutationOptions<AddMemberResponse, AddMemberError, Options<AddMemberData>> => {
    const mutationOptions: UseMutationOptions<AddMemberResponse, AddMemberError, Options<AddMemberData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ProjectMembers.addMember({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove Member
 *
 * Remove a member from a project.
 *
 * Only project admins and owners can remove members.
 * Members can also remove themselves (leave the project).
 *
 * Args:
 * slug: The project slug.
 * member_id: UUID of the member record.
 * current_user: The authenticated user.
 * member_service: Project member service.
 */
export const removeMemberMutation = (options?: Partial<Options<RemoveMemberData>>): UseMutationOptions<RemoveMemberResponse, RemoveMemberError, Options<RemoveMemberData>> => {
    const mutationOptions: UseMutationOptions<RemoveMemberResponse, RemoveMemberError, Options<RemoveMemberData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ProjectMembers.removeMember({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Member Role
 *
 * Update a member's role.
 *
 * Only project admins and owners can update roles.
 * Admins cannot modify their own role.
 *
 * Args:
 * slug: The project slug.
 * member_id: UUID of the member record.
 * request: Member update data.
 * current_user: The authenticated user.
 * member_service: Project member service.
 *
 * Returns:
 * The updated project member.
 */
export const updateMemberRoleMutation = (options?: Partial<Options<UpdateMemberRoleData>>): UseMutationOptions<UpdateMemberRoleResponse, UpdateMemberRoleError, Options<UpdateMemberRoleData>> => {
    const mutationOptions: UseMutationOptions<UpdateMemberRoleResponse, UpdateMemberRoleError, Options<UpdateMemberRoleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ProjectMembers.updateMemberRole({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};
